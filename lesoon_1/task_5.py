"""
Задание 5.
Задание на закрепление навыков работы со стеком
Реализуйте структуру "стопка тарелок".
Мы можем складывать тарелки в стопку и при превышении некоторого значения
нужно начать складывать тарелки в новую стопку.
Структура должна предусматривать наличие нескольких стеков.
Создание нового стека происходит при достижении предыдущим стеком порогового значения.
Реализуйте по аналогии с примером, рассмотренным на уроке, необходимые методы,
для реализации это структуры, добавьте новые методы (не рассмотренные в примере с урока)
для реализации этой задачи.
После реализации структуры, проверьте ее работу на различных сценариях
Подсказка:
Отдельне стопки можно реализовать через:
1) созд-е экземпляров стека (если стопка - класс)
или
2) lst = [[], [], [], [],....]
Примечание: в этом задании вспомните ваши знания по работе с ООП
и опирайтесь на пример урока
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
Задание творческое. Здесь нет жестких требований к выполнению.
"""


class StackPlates:
    # создаю объект
    def __init__(self):
        self.elems = []
        self.max_size = 5

    # проверка на пустоту
    def is_empty(self):
        if self.elems == []:
            return True
        else:
            return False

    # вставка элемента в конец.
    # если список пустой или полный, создаем пустую стопку и добавляем элемент
    # иначе просто добавляем
    def insert(self, elem):
        if self.elems == [] or len(self.elems[-1]) >= self.max_size:
            self.elems.append([])
            self.elems[-1].append(elem)
        else:
            self.elems[-1].append(elem)

    # извлечение элемента с конца
    def pop(self):
        result = self.elems[-1].pop()
        if len(self.elems[-1]) == 0:
            self.elems.pop()
        return result

    # возвращает последний элемент, без его удаления
    # в вузе нас учили, что если стек возвращает элемент, то обязательно удаляет его
    # так что я не уверена в том, что такое можно добавить
    def get_copy_val(self):
        return self.elems[-1][-1]

    # возвращает всю структуру целиком
    # такого тоже вроде не должно быть в структкре, создала для проверки
    def get_lst(self):
        return self.elems

    # число тарелок в общем, либо их число в стопке по индексу
    # если указан неверный индекс стопки, дает число всех тарелок
    def get_count_plates(self, idx=None):
        if not idx or idx >= len(self.elems):
            summa = 0
            for i in range(len(self.elems)):
                summa += len(self.elems[i])
            return summa
        else:
            return len(self.elems[idx])

    # число стопок
    def get_count_stacks(self):
        return len(self.elems)


# создаю стек
kitchen = StackPlates()

# проверяю, пустой ли он (пустой)
print('стек пустой после его создания: ', kitchen.is_empty())

# заполняю элементами
kitchen.insert(10)
kitchen.insert('88')
kitchen.insert(92)
kitchen.insert('75')
kitchen.insert(11)
kitchen.insert(64)
kitchen.insert(29)
kitchen.insert('53')
kitchen.insert(81)

# проверяю, пустой ли он (не пустой)
print('стек не пустой после заполнения: ', kitchen.is_empty())

# проверка функции get_count_plates()
print('число тарелок (без индекса): ', kitchen.get_count_plates())
print('число тарелок (с индексом 1): ', kitchen.get_count_plates(1))
print('число тарелок (с неверным индексом 5): ', kitchen.get_count_plates(5))

# проверяю функцию, берущую элемент без удаления его
print('последний элемент: ', kitchen.get_copy_val())

# смотрю сколько стопок создано
print('число стопок: ', kitchen.get_count_stacks())

# смотрю на всю структуру в целом
print('так выглядит структура: ', kitchen.get_lst())

# попорядку достаю все элементы с удалением
for j in range(kitchen.get_count_plates() - 1):
    print(kitchen.pop(), end=', ')
print(kitchen.pop())

# смотрю, пустой ли стек (путой)
print('стек пустой после извлечения всех элементов: ', kitchen.is_empty())



